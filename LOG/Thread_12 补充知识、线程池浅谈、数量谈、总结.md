# Thread_12 补充知识、线程池浅谈、数量谈、总结

## 一 补充一些知识点

### 1.1 虚假唤醒

wait中要有第二个参数（lambda）并且这个lambda中要正确判断要处理的公共数据是否存在

wait()，notify_one()，notify_all()

### 1.2 atomic

```c++
std::atomic<int> atm;
A()
{
    atm = 0;
    auto atm2 = atm; //这种定义时初始化操作不允许，显示“尝试引用已删除的函数”
    				//编译器内部肯定把拷贝构造函数给干掉了
    std::atomic<int> atm3;
    atm3 = atm; //尝试引用已删除的函数，拷贝赋值运算符也不让用
    //load(): 以原子方式读atomic对象的值
    std::atomic<int> atm2(atm.load());
    auto atm3(atm.load());
    
    //store()以原子方式写入内容
    atm2.store(12);
    atm2 = 12;
}
```

## 二 浅谈线程池

### 2.1 场景设想

服务器程序，->客户端， 每来一个客户端，就创建一个新线程为该客户端提供服务

（a）网络游戏，2万玩家不可能给每个玩家创建个新线程，此线程写法在这种情况下不通

（b）程序稳定问题，编写的代码中，偶尔创建一个线程这种代码，这种写法，让人感到不安

线程池：把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用线程的方式，就叫线程池

### 2.2 实现方式

在程序启动时，一次性的创建好一定数量的线程。10，8，100-200。更让人放心，觉得程序代码更加稳定

## 三 线程创建的数量谈

### 3.1 线程开的数量的极限问题

2000个线程基本就是极限，再创建线程就崩溃

### 3.2 线程创建数量建议

（a）采用某些技术开发程序。api接口提供商建议你  创建线程数量 = cpu数量，cpu*2，cpu**2+2，遵照专业建议和指示来

（b）创建多线程完成业务。一个线程等于一条通路，100要堵塞充值，我们这里开110个线程，是很合适的

（c）1500个线程，建议，线程数尽量不要超过500个，控制在200个之内



## 四 c++11多线程总结

windows，linux可跨平台